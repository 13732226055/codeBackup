package com.spring.impl;

import org.apache.log4j.Logger;
import org.springframework.transaction.NestedTransactionNotSupportedException;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionException;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionStatus;
import java.sql.Savepoint ;


public class NestedTest {
    /** 
     * Create a TransactionStatus for an existing transaction. 
     */  
	private static final Logger LOG = Logger.getLogger(NestedTest.class);
    private TransactionStatus handleExistingTransaction(  
            TransactionDefinition definition, Object transaction, boolean debugEnabled)  
            throws TransactionException {  
      
    	
        if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {  
            if (!isNestedTransactionAllowed()) {  
                throw new NestedTransactionNotSupportedException(  
                        "Transaction manager does not allow nested transactions by default - " +  
                        "specify 'nestedTransactionAllowed' property with value 'true'");  
            }  
            if (debugEnabled) {  
            	LOG.debug("Creating nested transaction with name [" + definition.getName() + "]");  
            }  
            if (useSavepointForNestedTransaction()) {  
                // Create savepoint within existing Spring-managed transaction,  
                // through the SavepointManager API implemented by TransactionStatus.  
                // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.  
                DefaultTransactionStatus status =  
                        new TransactionStatus(definition, transaction, false, false, debugEnabled, null);  
                status.createAndHoldSavepoint();  
                return status;  
            }  
            else {  
                // Nested transaction through nested begin and commit/rollback calls.  
                // Usually only for JTA: Spring synchronization might get activated here  
                // in case of a pre-existing JTA transaction.  
                doBegin(transaction, definition);  
                boolean newSynchronization = (this.transactionSynchronization != SYNCHRONIZATION_NEVER);  
                return new TransactionStatus(definition, transaction, true, newSynchronization, debugEnabled, null);  
            }  
        }  
    }
    public void createAndHoldSavepoint() throws TransactionException {  
        setSavepoint(getSavepointManager().createSavepoint());  
    }  
}
